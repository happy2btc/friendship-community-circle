<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle Discussions</title>
  <script type="module" src="/lib/supabase.js"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background-color: #f9f9f9; color: #333; padding: 2rem; padding-bottom: 100px; }
    h1 { text-align: center; color: #4a7c59; }
    .discussion-container { display: flex; flex-direction: column; gap: 1rem; }
    details.discussion-block { background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    details.discussion-block summary { padding: 1.5rem; font-size: 1.2em; font-weight: bold; cursor: pointer; list-style: none; }
    details.discussion-block summary::-webkit-details-marker { display: none; }
    details.discussion-block summary::before { content: '▶ '; font-size: 0.8em; }
    details[open].discussion-block > summary::before { content: '▼ '; }
    .summary-meta { font-size: 0.8em; font-weight: normal; color: #666; margin-left: 1rem; }
    .discussion-content { padding: 0 1.5rem 1.5rem 1.5rem; }
    .comment-thread { margin-top: 1rem; padding-left: 20px; }
    .comment { border-left: 2px solid #eee; padding-left: 20px; margin-top: 1rem; position: relative; }
    .comment-meta { font-size: 0.85em; color: #888; margin-bottom: 4px; }
    .comment-box { margin-top: 10px; padding: 10px; background-color: #f8f8f8; border-radius: 6px; }
    .comment-box {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .comment-box textarea {
      margin-bottom: 8px;
    }
    .comment-box textarea, .agreement-box textarea, .agreement-box input { font-size: 1.1em !important; }
    textarea { width: 95%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
    .action-button { background-color: #4a7c59; color: white; border: none; padding: 8px 12px; margin-top: 5px; cursor: pointer; border-radius: 4px; font-size: 0.9em; }
    .reply-button { background-color: #6c757d; font-size: 0.8em; padding: 4px 8px; }
    .agreement-box { margin-top: 2rem; padding: 1rem; background-color: #eef6f0; border-radius: 6px; }
    .floating-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      gap: 10px;
    }
    .floating-controls button, .floating-controls a {
      background-color: #6b4f1d;
      color: #fff;
      padding: 10px 15px;
      border-radius: 6px;
      text-decoration: none;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }
    .delete-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      cursor: pointer;
      color: #dc3545;
      font-size: 1.2em;
      padding: 0;
    }
    .delete-icon:hover {
      color: #a71d2a;
    }
    .author-instruction {
      background: #fffbe6;
      border: 1px solid #ffe58f;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
      color: #856404;
    }
    .error-message {
      color: #a94442;
      background: #fff0f0;
      border: 1px solid #a94442;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
      font-weight: bold;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Circle of Discussion</h1>
  <label for="circle-filter" style="font-weight:bold;">Filter by Circle:</label>
  <select id="circle-filter" style="margin-bottom:1em;"></select>
  <div id="discussion-container"></div>
  <div id="error-message" class="error-message" style="display:none;"></div>
  <div class="floating-controls">
    <button id="expand-all">Expand All</button>
    <button id="collapse-all">Collapse All</button>
    <a href="menu.html" class="menu-button">Return to Menu</a>
  </div>
  <script type="module">
    // Read circle_id from URL if present
    function getCircleIdFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('circle_id') || '';
    }
  let selectedCircleId = getCircleIdFromUrl();
    import { supabase } from '/lib/supabase.js';

    const discussionContainer = document.getElementById('discussion-container');
    const errorMessageDiv = document.getElementById('error-message');
    let currentUser;

    function showError(msg) {
      errorMessageDiv.textContent = msg;
      errorMessageDiv.style.display = 'block';
      setTimeout(() => {
        errorMessageDiv.style.display = 'none';
      }, 6000);
    }

    // --- Circle filter logic ---
    let circles = [];

    async function loadCircleFilter() {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;
      // Get all circles
      const { data: circlesData } = await supabase
        .from('circles')
        .select('id, name');
      circles = circlesData || [];
      let optionsHtml = '<option value="">Everyone (Public)</option>';
      circles.forEach(circle => {
        optionsHtml += `<option value="${circle.id}">${circle.name}</option>`;
      });
      const filter = document.getElementById('circle-filter');
      filter.innerHTML = optionsHtml;
      // Pre-select circle if circle_id is in URL
      if (selectedCircleId) {
        filter.value = selectedCircleId;
      }
      filter.addEventListener('change', () => {
        selectedCircleId = filter.value;
        loadDiscussions();
      });
    }

    async function loadDiscussions() {
      const { data: { user } } = await supabase.auth.getUser();
      currentUser = user;

      // Fetch only open and voting discussions
      let query = supabase.from('suggestions').select('*');
      if (selectedCircleId) {
        query = query.eq('circle_id', selectedCircleId)
                     .eq('status', 'open');
      } else {
        // Show all 'Everyone' discussions (circle_id IS NULL)
        query = query.is('circle_id', null)
                     .eq('status', 'open');
      }
      const { data: discussions, error: discussionsError } = await query;
      if (discussionsError) {
        showError(`Error loading discussions: ${discussionsError.message}`);
        discussionContainer.innerHTML = `<p>Error loading discussions: ${discussionsError.message}</p>`;
        return;
      }
      if (!discussions || discussions.length === 0) {
        discussionContainer.innerHTML = `<p>No active discussions at the moment.</p>`;
        return;
      }

      // Separate open and voting discussions
      const openDiscussions = discussions.filter(d => d.status === 'open');
      const votingDiscussions = discussions.filter(d => d.status === 'voting');

      // Get all suggestion IDs for comments
      const suggestionIds = discussions
        .map(d => d.id)
        .filter(id => typeof id === 'number' || (typeof id === 'string' && id.length > 0));

      let allComments = [];
      let commentsError = null;

      if (suggestionIds.length > 0) {
        const { data, error } = await supabase
          .from('comments')
          .select('*')
          .in('suggestion_id', suggestionIds)
          .order('created_at', { ascending: true });
        allComments = data;
        commentsError = error;
      } else {
        allComments = [];
        commentsError = null;
      }

      const allCommentsSafe = Array.isArray(allComments) ? allComments : [];

      // Gather all unique author_ids from discussions and comments
      const authorIds = [
        ...new Set([
          ...discussions.map(d => (d.author_id || '').trim().toLowerCase()),
          ...allCommentsSafe.map(c => (c.author_id || '').trim().toLowerCase())
        ])
      ];

      // Fetch all relevant profiles
      const { data: profilesData, error: profilesError } = await supabase
        .from('profiles')
        .select('id, full_name')
        .in('id', authorIds);

      const profiles = {};
      (profilesData || []).forEach(profile => {
        profiles[(profile.id || '').trim().toLowerCase()] = profile.full_name;
      });

      function getLatestCommentTime(suggestionId, comments, fallbackCreatedAt) {
        const relevant = comments.filter(c => c.suggestion_id === suggestionId);
        if (relevant.length === 0) return new Date(fallbackCreatedAt).getTime();
        return Math.max(...relevant.map(c => new Date(c.created_at).getTime()));
      }

      // Sort open discussions by latest activity (comments or creation)
      openDiscussions.sort((a, b) => {
        const aLatest = getLatestCommentTime(a.id, allCommentsSafe, a.created_at);
        const bLatest = getLatestCommentTime(b.id, allCommentsSafe, b.created_at);
        return bLatest - aLatest;
      });

      // Sort voting discussions by creation date (oldest first)
      votingDiscussions.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

      discussionContainer.innerHTML = '';

      // Render open discussions first
      for (const discussion of openDiscussions) {
        if (!discussion.title) continue;
        const normalizedAuthorId = (discussion.author_id || '').trim().toLowerCase();
        const suggestionId = discussion.id;
        const commentsForThisDiscussion = allCommentsSafe
          ? allCommentsSafe.filter(c => c.suggestion_id === suggestionId)
          : [];
        const totalCommentCount = commentsForThisDiscussion.length;
        const isAuthor = currentUser && ((currentUser.id || '').trim().toLowerCase() === normalizedAuthorId);
        const discussionBlock = document.createElement('details');
        discussionBlock.className = 'discussion-block';
        discussionBlock.dataset.suggestionId = suggestionId;
        const summary = document.createElement('summary');
        const authorName = profiles[normalizedAuthorId] || 'A member';
        summary.textContent = `${discussion.title} `;
        const summaryMeta = document.createElement('span');
        summaryMeta.className = 'summary-meta';
        summaryMeta.textContent = `(by ${authorName}, ${totalCommentCount} comments)`;
        summary.appendChild(summaryMeta);
        // Add link to reply-enabled page
        const replyLink = document.createElement('a');
        replyLink.href = `circle-discussion.html?discussion_id=${suggestionId}`;
        replyLink.textContent = 'View & Reply';
        replyLink.style.marginLeft = '1em';
        summary.appendChild(replyLink);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'discussion-content';
        contentDiv.dataset.suggestionId = suggestionId;
        const descriptionP = document.createElement('p');
        descriptionP.textContent = discussion.description;
        const commentButton = document.createElement('button');
        commentButton.className = 'action-button';
        commentButton.dataset.action = 'add-comment';
        commentButton.dataset.suggestionId = suggestionId;
        commentButton.textContent = 'Make a Comment';
        const threadDiv = document.createElement('div');
        threadDiv.className = 'comment-thread';
        threadDiv.id = `thread-for-${suggestionId}`;
        contentDiv.appendChild(descriptionP);
        contentDiv.appendChild(commentButton);
        contentDiv.appendChild(threadDiv);
        // Agreement box logic
        if (isAuthor && discussion.status === 'open') {
          const agreementBox = document.createElement('div');
          agreementBox.className = 'agreement-box';
          const instruction = document.createElement('div');
          instruction.className = 'author-instruction';
          instruction.textContent =
            'As the author, when you feel the discussion is complete, you may propose an agreement for the group to vote on.';
          const h3 = document.createElement('h3');
          h3.textContent = 'Propose an Agreement';
          const p = document.createElement('p');
          p.textContent = 'Once submitted, this discussion will be locked and will move to the voting page.';
          const label1 = document.createElement('label');
          label1.htmlFor = `agreement-text-${suggestionId}`;
          label1.textContent = 'Proposed Agreement Text:';
          const textarea = document.createElement('textarea');
          textarea.id = `agreement-text-${suggestionId}`;
          textarea.rows = 4;
          const br = document.createElement('br');
          const button = document.createElement('button');
          button.className = 'action-button';
          button.dataset.action = 'submit-agreement';
          button.dataset.suggestionId = suggestionId;
          button.textContent = 'Submit and Start Vote';
          agreementBox.append(instruction, h3, p, label1, textarea, br, button);
          contentDiv.appendChild(agreementBox);
        }
        discussionBlock.appendChild(summary);
        discussionBlock.appendChild(contentDiv);
        discussionContainer.appendChild(discussionBlock);
        renderComments(commentsForThisDiscussion, threadDiv, null, profiles, currentUser);
      }

      // Render voting discussions at the bottom
      for (const discussion of votingDiscussions) {
        if (!discussion.title) continue;
        const normalizedAuthorId = (discussion.author_id || '').trim().toLowerCase();
        const suggestionId = discussion.id;
        const commentsForThisDiscussion = allCommentsSafe
          ? allCommentsSafe.filter(c => c.suggestion_id === suggestionId)
          : [];
        const totalCommentCount = commentsForThisDiscussion.length;
        const discussionBlock = document.createElement('details');
        discussionBlock.className = 'discussion-block';
        discussionBlock.dataset.suggestionId = suggestionId;
        const summary = document.createElement('summary');
        const authorName = profiles[normalizedAuthorId] || 'A member';
        summary.textContent = `${discussion.title} `;
        const summaryMeta = document.createElement('span');
        summaryMeta.className = 'summary-meta';
        summaryMeta.textContent = `(by ${authorName}, ${totalCommentCount} comments, sent to voting)`;
        summary.appendChild(summaryMeta);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'discussion-content';
        contentDiv.dataset.suggestionId = suggestionId;
        const descriptionP = document.createElement('p');
        descriptionP.textContent = discussion.description;
        const threadDiv = document.createElement('div');
        threadDiv.className = 'comment-thread';
        threadDiv.id = `thread-for-${suggestionId}`;
        contentDiv.appendChild(descriptionP);
        contentDiv.appendChild(threadDiv);
        discussionBlock.appendChild(summary);
        discussionBlock.appendChild(contentDiv);
        discussionContainer.appendChild(discussionBlock);
        renderComments(commentsForThisDiscussion, threadDiv, null, profiles, currentUser);
      }
    }
  // Load filter and discussions on page load
  loadCircleFilter();
  selectedCircleId = '';
  loadDiscussions();

    function renderComments(commentList, parentElement, parentId = null, profiles = {}, currentUser = null) {
      const commentsToRender = commentList.filter(c => c.parent_id === parentId);
      for (const comment of commentsToRender) {
        const normalizedAuthorId = (comment.author_id || '').trim().toLowerCase();

        const commentDiv = document.createElement('div');
        commentDiv.className = 'comment';

        const authorName = profiles[normalizedAuthorId] || 'Unknown';
        const createdAt = new Date(comment.created_at).toLocaleString();
        const metaDiv = document.createElement('div');
        metaDiv.className = 'comment-meta';
        metaDiv.textContent = `by ${authorName} on ${createdAt}`;

        const p = document.createElement('p');
        p.textContent = comment.content;

        const replyButton = document.createElement('button');
        replyButton.className = 'action-button reply-button';
        replyButton.dataset.action = 'reply';
        replyButton.dataset.commentId = comment.id;
        replyButton.dataset.suggestionId = comment.suggestion_id;
        replyButton.textContent = 'Reply';

        commentDiv.appendChild(metaDiv);
        commentDiv.appendChild(p);
        commentDiv.appendChild(replyButton);

        if (
          currentUser &&
          ((currentUser.id || '').trim().toLowerCase() === normalizedAuthorId)
        ) {
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-icon';
          deleteBtn.title = 'Delete comment';
          deleteBtn.innerHTML = '🗑️';
          deleteBtn.onclick = async () => {
            if (!confirm('Delete this comment?')) return;
            const { error } = await supabase.from('comments').delete().eq('id', comment.id);
            if (error) showError('Error deleting comment: ' + error.message);
            else await loadDiscussions();
          };
          commentDiv.appendChild(deleteBtn);
        }

        parentElement.appendChild(commentDiv);
        renderComments(commentList, commentDiv, comment.id, profiles, currentUser);
      }
    }

    document.addEventListener('click', async (e) => {
      const target = e.target;
      const actionTarget = target.closest('[data-action]');

      if (target.id === 'expand-all') {
        document.querySelectorAll('details.discussion-block').forEach(d => d.open = true);
        return;
      }
      if (target.id === 'collapse-all') {
        document.querySelectorAll('details.discussion-block').forEach(d => d.open = false);
        return;
      }

      if (!actionTarget) return;

      const action = actionTarget.dataset.action;

      if (action === 'add-comment' || action === 'reply') {
        const parentElement = action === 'reply' ? actionTarget.parentElement : actionTarget.nextElementSibling;
        const parentId = action === 'reply' ? actionTarget.dataset.commentId : null;
        const suggestionId = actionTarget.dataset.suggestionId;
        showCommentBox(parentElement, suggestionId, parentId);
      }

      if (action === 'submit-agreement') {
        if (!currentUser) return showError('You must be logged in to submit an agreement.');

        let suggestionId = actionTarget.dataset.suggestionId;
        if (!suggestionId) {
          const discussionBlockDiv = actionTarget.closest('.discussion-block');
          if (discussionBlockDiv) {
            suggestionId = discussionBlockDiv.dataset.suggestionId;
          }
        }

        const textarea = actionTarget.closest('.agreement-box').querySelector('textarea');
        const agreementText = textarea ? textarea.value : '';

        if (!agreementText.trim()) return showError('Agreement text cannot be empty.');
        if (!suggestionId) return showError('Suggestion ID is missing.');

        // --- Check if agreement already exists ---
        const { data: existingAgreements, error: fetchError } = await supabase
          .from('agreements')
          .select('id')
          .eq('suggestion_id', suggestionId);

        if (fetchError) {
          showError(`Error checking for existing agreement: ${fetchError.message}`);
          return;
        }

        if (existingAgreements && existingAgreements.length > 0) {
          showError('An agreement has already been submitted for this discussion.');
          return;
        }

        // --- Update status to 'voting' before submitting agreement ---
        console.log('Updating suggestion status to voting for id:', suggestionId);
        const { error: updateError } = await supabase
          .from('suggestions')
          .update({ status: 'voting' })
          .eq('id', suggestionId);

        if (updateError) {
          showError(`Error updating discussion status: ${updateError.message}`);
          console.error(updateError);
          return;
        }

        // --- Insert agreement into agreements table ---
        const { error: insertError } = await supabase.from('agreements').insert({
          suggestion_id: suggestionId,
          agreement_text: agreementText,
          proposer_id: currentUser.id,
          status: 'voting'
        });

        if (insertError) {
          showError(`Error submitting agreement: ${insertError.message}`);
        } else {
          alert('Agreement submitted successfully! You will now be taken to the voting page.');
          window.location.href = 'agreements.html';
        }
      }
    });

    function showCommentBox(parentElement, suggestionId, parentCommentId = null) {
      if (parentElement.querySelector('.comment-box')) {
        parentElement.querySelector('.comment-box').remove();
      }
      const box = document.createElement('div');
      box.className = 'comment-box';
      const textarea = document.createElement('textarea');
      textarea.placeholder = 'Type your thoughts...';
      const button = document.createElement('button');
      button.className = 'action-button';
      button.textContent = 'Submit';
      button.onclick = async () => {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return showError('You must be logged in to comment.');
        const content = textarea.value;
        if (!content.trim()) return;
        const { error } = await supabase.from('comments').insert({ suggestion_id: suggestionId, parent_id: parentCommentId, content: content, author_id: user.id });
        if (error) { showError(`Error: ${error.message}`); }
        else { await loadDiscussions(); }
      };
      box.appendChild(textarea);
      box.appendChild(button);
      parentElement.appendChild(box);
      textarea.focus();
    }

    loadDiscussions();
  </script>
</body>
</html>